{"name":"Angular-components-api","tagline":"Simple yet effective API for components based communication over angular framework","body":"# angular-components-api\r\nSimple yet effective API for components based communication over angular framework\r\n\r\n#Work in progress...\r\n\r\n# Promises instead of events\r\nA little bit reworked promises which allow us to assign handlers and execute them if something coming.\r\nI've called them EventListeners because of their purpose, but there are too many differences between them to compare.\r\nTo use them you need only object of aw.EventLsitener\r\n```javascript\r\n    // let's create EventListener object\r\n    var listener = aw.events.EventListener.create();\r\n    //subsctribe for event its going to fire\r\n    //handle is just an alias of then()\r\n    listener.handle(function(data){\r\n        console.log('first listener', data);\r\n    });\r\n    listener.handle(function(){\r\n        console.log('second listener');\r\n        return 'data';\r\n    }).then(function(data){\r\n        console.log('third listener', data);\r\n    });\r\n    //then fire event with some data\r\n    listener.$fire('ok');\r\n    /*Output:\r\n     first listener ok\r\n     second listener\r\n     third listener data\r\n     */\r\n```\r\nBasically it just executes list of functions/handlers passing some data object to them.\r\nThis communication trick was used not to replace events but mix them, each have own purpose.\r\nI found them to be better solution to communicate between components, because they are\r\naccessible locally, only between components close to each other. So they are good to connect,\r\nfor example, child and parent components or siblings.\r\n\r\nSince they are created as objects, to have access to them, they should be available as properties\r\nor returned via method calls, so if you misspell such \"event\" it will not die silently, but you will\r\nsee runtime error about accessing method of undefined.\r\n```javascript\r\n    //Controller 1\r\n    $scope.$on(\"passData\", function(data){\r\n      console.log(data);\r\n    });\r\n    //Controller 2 has typo in event name\r\n    $scope.$emit(\"passDeta\", \"some data\");\r\n```\r\nThey just cannot interfere with other such notifications, so you are free of string, typos and naming conventions.\r\n```javascript\r\n    $scope.$on(\"passData1\", function(dataType1){\r\n      console.log(dataType1);\r\n    });\r\n    $scope.$on(\"passData2\", function(dataType2){\r\n      console.log(dataType2);\r\n    });\r\n    $scope.$on(\"passData3\", function(dataType3){\r\n      console.log(dataType3);\r\n    });\r\n```\r\nTo sum up:\r\n* Promises are real properties living on components facade, they will trigger runtime error if you misspell them.\r\n* They don't need to have some complex logic, they have local area of availability.\r\n* You can define what events exactly will be fired from component with property per promise. Most IDEs will have context help regarding this.\r\n* You can still use events as you always do, this is only recommended to use promises as communication base between components.\r\n\r\n# Component\r\nCurrently only angular controllers are capable to be represented as components.\r\nEach component must have controller and facade object which will be used as public API of controller.\r\nFacade object will be passed to parent and children components on handshake sequence. To use controller as component, it should be registered\r\n```javascript\r\n    module.controller(Page.NAME, [\r\n      \"$scope\",\r\n      \"$http\",\r\n      aw.components.Component.registerController(PageController, Page)\r\n    ]);\r\n```\r\nHere PageController is angular controller and Page is class which will be instantiated every time when controller is initialized.\r\nAfter \"registration\" controller will be mixed with aw.components.utils.ComponentController class and will gain some methods it needs to be a component:\r\n* $initialize - initialize component instance, must be called as sooner as better.\r\n* $createListener - creates new event-promise\r\n* $refresh - timeout $digest call. even if this function will be called N times in a row, $digest will be called once.    \r\nAnd predefined events-promises:\r\n* $addedToParent - when this component is added to parent, you will receive link to parent component facade.\r\n* $childAdded - when child component is added.\r\n* $childRemoved - when child component is added.\r\n\r\n# Communication between components\r\nWhen component instance created and its added to application, parent component will be notified with \"addedToParent\" event.\r\nThen component will be notified that its added to some parent component so they can start communicating.\r\n\r\n\r\n# IDE Templates\r\nWebstorm Templates:\r\n* bundle template - Includes Component, ComponentController and Directive definitions\r\n* complete template - Includes Everything templated, lots of settings\r\n* component template - Component facade class with configuration\r\n* controller template - Angular Component-ready Controller template  \r\n[WebStorm Templates Help page](https://www.jetbrains.com/webstorm/help/creating-and-editing-file-templates.html#d1273479e250)\r\n\r\nhttp://daringfireball.net/projects/markdown/syntax#link","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}